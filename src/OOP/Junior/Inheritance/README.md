# OOP--inheritance

[例程](./Inheritance.java)

## 继承的细节

1. 子类**必须**调用父类的构造器，完成父类的初始化
2. 当创建子类对象时，不管使用子类的哪个构造器，**默认情况**下总会去调用**父类**的**无参构造器**。如果父类没有提供无参构造器，则必须在子类的构造器中用super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过
3. super在使用时，需要放在构造器**第一行**。
4. **super()**和**this()**都只能放在构造器第一行，因此这两个方法**不能共存**在一个构造器。
5. Java所有类都是Object类的子类，**Object是所有类的基类**。
6. `cltr+H`查看继承关系
7. 子类最多**只能**继承**一个父类**

## super的用法 

super给编程带来的便利/细节

1. 调用父类的构造的的好处(分工明确，父类属性由父类初始化，子类的属性有子类初始化)
2. 当子类中有父类的成员（属性和方法）**重名**时，为了访问父类的成员，必须**通过super**。如果**没有重名**，使用super、this、直接访问的**效果是一样**的。
3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个积累中都有同名的成员，**使用super访问遵循就近原则**。A->B->C

## 方法重写/覆盖(override)

 - 基本概念：方法覆盖（重写）就是子类有一个方法，和父类的的某个方法对外几乎一致（方法名称、返回类型、参数一致），那么我们就说这个子类的这个方法覆盖了父类的该方法。

1. 重写方法与原方法的**参数列表、方法名称**需要完全一致。
2. 重写方法**返回类型**需要是**与原方法返回类型一致**的，**或者是父类返回类型的子类**。（如 `public String func(){} 重写 public Object func(){}`）
3. 子类方法**不能缩小**父类方法的**访问权限**（public > protected > default > private）。
